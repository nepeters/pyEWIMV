#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Nov 17 19:03:46 2019

@author: nate
"""

"""
Sample coordnate system: z || up, x âŸ‚ y
Crystal coordinate system: z || [001], x || [100], y || [010]
this goes scattering vector -> intersection in bunge
"""

import os

import numpy as np
from scipy.spatial.transform import Rotation as R
from tqdm import tqdm

from classes import poleFigure, bunge
from utils.orientation import symmetrise, normalize, XYZtoSPH, eu2om, om2eu

dir_path = os.path.dirname(os.path.realpath('__file__'))

#crystalSym = 'm-3m'
#sampleSym = '1'
#cellSize = np.deg2rad(5)
#hkls = [(1,1,1),(2,0,0),(2,2,0)]
#
#bkgd111path = '/home/nate/wimv/Data/316L_AM/Horizontal_BDup/Cr Tube/Bkgd_73_316L_horiz.xrdml'
#bkgd200path = '/home/nate/wimv/Data/316L_AM/Horizontal_BDup/Cr Tube/Bkgd_100_316L_horiz.xrdml'
#bkgd220path = '/home/nate/wimv/Data/316L_AM/Horizontal_BDup/Cr Tube/Bkgd_100_316L_horiz.xrdml'
#
#bkgds = [bkgd111path,bkgd200path,bkgd220path]
#bkgd = poleFigure(bkgds, hkls, crystalSym, 'xrdml',subtype='bkgd')
#
#pf111path = '/home/nate/wimv/Data/316L_AM/Horizontal_BDup/Cr Tube/110_pf_316L_horiz.xrdml'
#pf200path = '/home/nate/wimv/Data/316L_AM/Horizontal_BDup/Cr Tube/200_pf_316L_horiz.xrdml'
#pf220path = '/home/nate/wimv/Data/316L_AM/Horizontal_BDup/Cr Tube/211_pf_316L_horiz.xrdml'
#
##bkgd111path = '/home/nate/wimv/Data/32.5_ bkgd.xrdml'
##bkgd200path = '/home/nate/wimv/Data/55_bkgd.xrdml'
##bkgd220path = '/home/nate/wimv/Data/55_bkgd.xrdml'
##
##bkgds = [bkgd111path,bkgd200path,bkgd220path]
##bkgd = poleFigure(bkgds, hkls, crystalSym, 'xrdml',subtype='bkgd')
##
##def111path = '/home/nate/wimv/Data/defocus_38.xrdml'
##def200path = '/home/nate/wimv/Data/defocus_45.xrdml'
##def220path = '/home/nate/wimv/Data/defocus_65.xrdml'
##
##defs = [def111path,def200path,def220path]
##defocus = poleFigure(defs, hkls, crystalSym, 'xrdml',subtype='defocus')
##
##pf111path = '/home/nate/wimv/Data/111pf_2T=38.xrdml'
##pf200path = '/home/nate/wimv/Data/200pf_2T=45.xrdml'
##pf220path = '/home/nate/wimv/Data/220pf_2theta=65.xrdml'
#
#pfs = [pf111path,pf200path,pf220path]
#pf = poleFigure(pfs, hkls, crystalSym, 'xrdml')
#pf.correct(bkgd=bkgd)
#pf.normalize()

crystalSym = 'm-3m'
sampleSym = '1'
cellSize = np.deg2rad(5)

hkls = []
files = []

datadir = "/home/nate/wimv/Data/NOMAD Aluminum - no abs/pole figures/combined"

for file in os.listdir(datadir):
    
    pfName = file.split(')')[0].split('(')[1]
    
    try:
        hkls.append(tuple([int(c) for c in pfName]))
        files.append(os.path.join(datadir,file))
    except: #not hkls
        continue
    
    sortby = [sum([c**2 for c in h]) for h in hkls]
    hkls = [x for _, x in sorted(zip(sortby,hkls), key=lambda pair: pair[0])]
    files = [x for _, x in sorted(zip(sortby,files), key=lambda pair: pair[0])]
    
chi = R.from_euler('x',(13),degrees=True).as_dcm() 
om = R.from_euler('y',(90),degrees=True).as_dcm() 
phi = R.from_euler('z',(-88),degrees=True).as_dcm()

rot = chi.dot(phi).dot(om)
pf = poleFigure(files,hkls,crystalSym,'nd')
pf.rotate(rot)

od = bunge(cellSize, crystalSym, sampleSym)
hkls = np.array(hkls)

symHKL = symmetrise(crystalSym, hkls)
symHKL = normalize(symHKL)

#y1, y2, y3 = np.meshgrid(alpsteps, betsteps, np.zeros_like(alpsteps))

# %%

""" build unique list of y for efficient computation """

for fi,y in pf.y.items():
    
    if fi == 0: yall = np.copy(y)        
    else: yall = np.append(yall,y,axis=0)
        
""" return array of indicies to reconstruct yall from unique_y - these are the unique y indicies """

unique_y, inver = np.unique(yall, return_inverse=True, axis=0)

for fi,y in pf.y.items():
    
    pf.y[fi] = np.append(y, inver[:len(y),None], axis=1)
        
# %%
        
xyz = {}   
ypol = {}
hpol = {}

Hr_brute = {}

Hr_scipy = {}
Yr_scipy = {}

for fi,fam in enumerate(symHKL):

    #polar coordinates of hkls
    hpol[fi] = XYZtoSPH(fam,proj='none')
    
    Hr_brute[fi] = np.zeros((3,3,len(fam)))
    
    for hi,h in enumerate(hpol[fi]):
        
        Hr_brute[fi][:,:,hi] = eu2om((0,h[1],h[0]))
    
Yr_brute = np.zeros((3,3,len(unique_y)))

for yi,y in enumerate(unique_y):
    
    Yr_brute[:,:,yi] = eu2om((y[1],y[0],0))

#    
gamma = np.radians(np.arange(0,360,5))
g_gam = [eu2om((ga,0,0),out=None) for ga in gamma]

# %%

""" loop for fibre """

""" extremely slow... """

bunge_fibre = {}

for yi in range(unique_y.shape[0]):
    
    if yi in 




#bunge_fibre = {}
#
#Y_gam_brute = {} 
#
#for yi in range(Yr_brute.shape[2]):
#    
#    Y_gam_brute[yi] = np.zeros((3,3,len(g_gam))) 
#    
#    for gi,ga in enumerate(g_gam):
#        
#        Y_gam_brute[yi][:,:,gi] = ga @ Yr_brute[:,:,yi]
#
#for fi in tqdm(range(len(symHKL))):
#    
#    bunge_fibre[fi] = {}
#    
#    for h in range(Hr_brute[fi].shape[2]):
#        
#        Hr_ga_g = [Hr_brute[fi][:,:,h] @ ga for ga in g_gam]
#        
#        g = np.zeros((Yr_brute[fi].shape[2],3,3))
#        
#        for y in range(Yr_brute[fi].shape[2]):
#            
#            if y in bunge_fibre[fi]:
#                
#                for i,hga in enumerate(Hr_ga_g):
#                    
#                    g[y,:,:] = hga @ Yr_brute[fi][:,:,y]
#                    
#                bunge_fibre[fi][y].append(om2eu(g))
#           
#            else: bunge_fibre[fi][y] = []
#            
           

#yList=[]
#
#for y in yCoordSPH: #counter
#    eulerFamilyList=[]
#    for hFamily in hCoordSPH:
#        eulerList=[]
#        for h in hFamily:
#            if h[1] < 0:
#                h[1] += 2*np.pi
#
#            if y[1] < 0:
#                y[1] += 2*np.pi
#
#            Hr=eu2om([0,h[1],h[0]])
#            Yr=eu2om([y[0],y[1],0])            
#
#            g=[Hr.dot(eu2om([gamma[index],0,0])).dot(Yr) for index in range(len(gamma))]
#
#            euler=np.asarray([om2eu(g[gIdx]) for gIdx in range(len(g))])
#
#            eulerList.append(np.degrees(euler)) #combine all h in family
#        eulerFamilyList.append(eulerList)# combine all family for y
#    yList.append(eulerFamilyList)



# %%

#import scipy
#
##yFundZone=[]
#pFundZone=[]
#for yIdx,y in enumerate(yList): #y (sample)
##    fibreFundZone=[]
#    for pIdx,p in enumerate(y): #pole
#        hFundZone=[]
#        for hIdx,h in enumerate(p): #h (crystal)
#            fundZone = [ori for ori in h if ori[0] <= 360.0 and ori[1] <= 90.0 and ori[2] <= 90.0]
#            if len(fundZone) > 1:
#                fundZone = np.vstack(fundZone)
#                hIdxList=np.full((len(fundZone),1),hIdx)
#                pIdxList=np.full((len(fundZone),1),pIdx)
#                yIdxList=np.full((len(fundZone),1),yIdx)
#                hFundZone.append(np.column_stack((fundZone,hIdxList,pIdxList,yIdxList)))
#        pFundZone.append(hFundZone)
##    yFundZone.append(fibreFundZone)
#
#flatPList=np.vstack([np.vstack(y) for y in pFundZone])
#pInt=[]
#queryStore=[]
#
#for pIdx in range(len(pole)):
#
#    hInt=[]
#
#    for hIdx in range(len(hCoordXYZ[pIdx])):
#
#        if len(pole) > 1: #if more than one poles are tested, then must check for specific pole
#
#            otherList=flatPList[np.where((flatPList[:,3] != hIdx) & (flatPList[:,4] != pIdx))] #picks values that aren't of the same [hkl] in a <hkl>
#            testList=flatPList[np.where((flatPList[:,3] == hIdx) & (flatPList[:,4] == pIdx))] #picks values that are of the same [hkl] in a <hkl>
#
#        else:
#
#            otherList=flatPList[np.where((flatPList[:,3] != hIdx))] #picks values that aren't of the same [hkl] in a <hkl>
#            testList=flatPList[np.where((flatPList[:,3] == hIdx))] #picks values that are of the same [hkl] in a <hkl>
#
#        """we will test all y's simulatneously to save time?"""
#
#        print(len(otherList))
#        print(len(testList))
#
#        if len(testList) >= 1:
#
#            otherKDTree=scipy.spatial.cKDTree(otherList[:,0:3])
#            testKDTree=scipy.spatial.cKDTree(testList[:,0:3])
#
#            query=otherKDTree.query_ball_tree(testKDTree,0.866,p=2) #test the orientation fibre for a selected [hkl] in a <hkl> against all other orientaiton fibers
#
#            queryInt=[]
#
#            queryStore.append(query)
#            print('testing')
#
#            for ori,q in zip(otherList,query):
#                if len(q) > 1:
#                    queryInt.append(np.vstack((ori,testList[int(q[0])])))
#
#            if len(queryInt) > 0:
#                hInt.append(queryInt)
#
#    pInt.append(hInt)
#
#flatIntList = [[inter,yList[int(inter[0,5])][int(inter[0,4])][int(inter[0,3])],yList[int(inter[1,5])][int(inter[1,4])][int(inter[1,3])]] for p in pInt for h in p for inter in h]
#flatIntArray = np.vstack([inter[0][0,:] for inter in flatIntList])

# %% 

"""angle testing"""

#from functions import eu2om
#
#yAngle = [np.arccos(np.dot(yCoordXYZ[int(inter[0][0,5]),0:3],yCoordXYZ[int(inter[0][1,5]),0:3])/(np.linalg.norm(yCoordXYZ[int(inter[0][0,5]),0:3])*np.linalg.norm(yCoordXYZ[int(inter[0][1,5]),0:3]))) for inter in flatIntList]
#
#hTest = np.vstack([[int(inter[0][0,4]),int(inter[0][0,3]),int(inter[0][1,4]),int(inter[0][1,3])] for inter in flatIntList])
#yTest = np.vstack([[int(inter[0][0,5]),int(inter[0][1,5])] for inter in flatIntList])
#hAngle = [np.arccos(np.dot(hCoordXYZn[int(inter[0][0,4])][int(inter[0][0,3]),:],hCoordXYZn[int(inter[0][1,4])][int(inter[0][1,3]),:])/(np.linalg.norm(hCoordXYZn[int(inter[0][0,4])][int(inter[0][0,3]),:])*np.linalg.norm(hCoordXYZn[int(inter[0][1,4])][int(inter[0][1,3]),:]))) for inter in flatIntList]
#
#
#intYUnique,intYUniqueIdx = np.unique(yTest,axis=0,return_index=True)
#
#intHUnique,intHUniqueIdx = np.unique(hTest[intYUniqueIdx],axis=0,return_index=True)
#
##hOM = [eu2om(list(flatIntList[idx][0][0,0:3])) for idx in intYUniqueIdx]

# %% 
"""test intersection points against bunge grid"""

#phi1Max=360
#phiMax=90
#phi2Max=90
#
#res = 5
#
#eulerList = []
#
#for phi2 in np.arange(0,phi2Max,res):
#    for phi in np.arange(0,phiMax,res):
#        for phi1 in np.arange(0,phi1Max,res):
#            eulerList.append(np.array((phi1,phi,phi2)))
#
#eulerList=np.vstack(eulerList)
#
#from sklearn.neighbors import NearestNeighbors
#
#dB = bungeMetric(np.array((0,0,0)),np.array((res,res,res)))
#
##distFunc = DistanceMetric.get_metric('pyfunc', func=bungeMetric)
#neigh = NearestNeighbors(5, dB, algorithm='ball_tree', metric=bungeMetric, n_jobs=-1).fit(flatIntArray[:,0:3])
#distNN,indexNN = neigh.radius_neighbors(eulerList)
#
#temp = [np.unique(ori) for ori in indexNN]
#maxI=len(flatIntArray)
#uniqueNN = [np.array((ori[ori != maxI])) for ori in temp]
#uniqueDistNN = [np.array((d[~np.isinf(d)])) for d in distNN]

# %%

#"""plot intersections with the two fibres looping"""
#
#fig = mlab.figure(1,bgcolor=(0.5, 0.5, 0.5))
#fig2 = mlab.figure(2,bgcolor=(0.5,0.5,0.5))
#
#phi1ax=mlab.quiver3d(0,0,0,360,0,0,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 0.160, 1),figure=fig)
#phi1ax.glyph.glyph_source.glyph_source.tip_radius = 0.02
#phi1ax.glyph.glyph_source.glyph_source.tip_length = 0.1
#phi1ax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
#phiax=mlab.quiver3d(0,0,0,0,180,0,line_width=0.5,scale_factor=1,mode='arrow',color=(1, 0.039, 0.039),figure=fig)
#phiax.glyph.glyph_source.glyph_source.tip_radius = 0.04
#phiax.glyph.glyph_source.glyph_source.tip_length = 0.2
#phiax.glyph.glyph_source.glyph_source.shaft_radius = 0.01
#phi2ax=mlab.quiver3d(0,0,0,0,0,360,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 1, 0.054),figure=fig)
#phi2ax.glyph.glyph_source.glyph_source.tip_radius = 0.02
#phi2ax.glyph.glyph_source.glyph_source.tip_length = 0.1
#phi2ax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
#
#otherPlot = mlab.points3d(90,90,90,mode='point',color=(0,0,0),figure=fig)
#otherPlot.actor.property.render_points_as_spheres = True
#otherPlot.actor.property.point_size = 3
#
#testPlot = mlab.points3d(90,90,90,mode='point',color=(0.039, 1, 0.054),figure=fig)
#testPlot.actor.property.render_points_as_spheres = True
#testPlot.actor.property.point_size = 3
#
#intPlot = mlab.points3d(90,90,90,mode='point',color=(1, 0.039, 0.039),figure=fig)
#intPlot.actor.property.render_points_as_spheres = True
#intPlot.actor.property.point_size = 8
#
#phi1ax=mlab.quiver3d(0,0,0,1,0,0,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 0.160, 1),figure=fig)
#phi1ax.glyph.glyph_source.glyph_source.tip_radius = 0.02
#phi1ax.glyph.glyph_source.glyph_source.tip_length = 0.1
#phi1ax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
#phiax=mlab.quiver3d(0,0,0,0,1,0,line_width=0.5,scale_factor=1,mode='arrow',color=(1, 0.039, 0.039),figure=fig)
#phiax.glyph.glyph_source.glyph_source.tip_radius = 0.02
#phiax.glyph.glyph_source.glyph_source.tip_length = 0.1
#phiax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
#phi2ax=mlab.quiver3d(0,0,0,0,0,1,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 1, 0.054),figure=fig)
#phi2ax.glyph.glyph_source.glyph_source.tip_radius = 0.02
#phi2ax.glyph.glyph_source.glyph_source.tip_length = 0.1
#phi2ax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
#
#@mlab.animate(delay=700)
#def anim():
#    while True:
##        for inter in flatIntList:
##            otherPlot.mlab_source.reset(x=inter[1][:,0],
##                                        y=inter[1][:,1],
##                                        z=inter[1][:,2])
##            testPlot.mlab_source.reset(x=inter[2][:,0],
##                                       y=inter[2][:,1],
##                                       z=inter[2][:,2])
##            intPlot.mlab_source.reset(x=inter[0][1,0],
##                                      y=inter[0][1,1],
##                                      z=inter[0][1,2])
#        for idx in intUniqueIdx:
#            otherPlot.mlab_source.reset(x=flatIntList[idx][1][:,0],
#                                        y=flatIntList[idx][1][:,1],
#                                        z=flatIntList[idx][1][:,2])
#            testPlot.mlab_source.reset(x=flatIntList[idx][2][:,0],
#                                       y=flatIntList[idx][2][:,1],
#                                       z=flatIntList[idx][2][:,2])
#            intPlot.mlab_source.reset(x=flatIntList[idx][0][1,0],
#                                      y=flatIntList[idx][0][1,1],
#                                      z=flatIntList[idx][0][1,2])
#            yield
#
#anim()
#mlab.show(stop=True)

# %%

"""plot all intersections as points"""

#fig2 = mlab.figure(bgcolor=(0.5, 0.5, 0.5))
#
#phi1ax=mlab.quiver3d(0,0,0,360,0,0,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 0.160, 1))
#phi1ax.glyph.glyph_source.glyph_source.tip_radius = 0.02
#phi1ax.glyph.glyph_source.glyph_source.tip_length = 0.1
#phi1ax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
#phiax=mlab.quiver3d(0,0,0,0,90,0,line_width=0.5,scale_factor=1,mode='arrow',color=(1, 0.039, 0.039))
#phiax.glyph.glyph_source.glyph_source.tip_radius = 0.08
#phiax.glyph.glyph_source.glyph_source.tip_length = 0.4
#phiax.glyph.glyph_source.glyph_source.shaft_radius = 0.02
#phi2ax=mlab.quiver3d(0,0,0,0,0,90,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 1, 0.054))
#phi2ax.glyph.glyph_source.glyph_source.tip_radius = 0.08
#phi2ax.glyph.glyph_source.glyph_source.tip_length = 0.4
#phi2ax.glyph.glyph_source.glyph_source.shaft_radius = 0.02
#
#totNumPlots=len(flatIntList)
#
#colors=plt.cm.viridis(np.linspace(0,1,totNumPlots))
#
##flatInt = np.vstack([inter[0][0,:] for inter in flatIntList])
#
##for inter,color in zip(flatIntList,colors):
##    c=list(color)
##    c.remove(1.0)
##    c=tuple(c)
##    intPlot=mlab.points3d(inter[0][0,0],inter[0][0,1],inter[0][0,2],mode='point',color=c)
##    intPlot.actor.property.render_points_as_spheres = True
##    intPlot.actor.property.point_size = 8
#
#intPlot=mlab.points3d(flatIntArray[:,0],flatIntArray[:,1],flatIntArray[:,2],mode='point',color=(1,0.039,0.039))
#intPlot.actor.property.render_points_as_spheres = True
#intPlot.actor.property.point_size = 3
    
# %%

"""plot all fibres"""

#fig3 = mlab.figure(bgcolor=(0.5, 0.5, 0.5))
#
#phi1ax=mlab.quiver3d(0,0,0,360,0,0,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 0.160, 1))
#phi1ax.glyph.glyph_source.glyph_source.tip_radius = 0.02
#phi1ax.glyph.glyph_source.glyph_source.tip_length = 0.1
#phi1ax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
#phiax=mlab.quiver3d(0,0,0,0,90,0,line_width=0.5,scale_factor=1,mode='arrow',color=(1, 0.039, 0.039))
#phiax.glyph.glyph_source.glyph_source.tip_radius = 0.08
#phiax.glyph.glyph_source.glyph_source.tip_length = 0.4
#phiax.glyph.glyph_source.glyph_source.shaft_radius = 0.02
#phi2ax=mlab.quiver3d(0,0,0,0,0,90,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 1, 0.054))
#phi2ax.glyph.glyph_source.glyph_source.tip_radius = 0.08
#phi2ax.glyph.glyph_source.glyph_source.tip_length = 0.4
#phi2ax.glyph.glyph_source.glyph_source.shaft_radius = 0.02
#
#flatYlist = [np.vstack([flatPList[idx,0:3] for idx in range(len(flatPList)) if flatPList[idx,5]==yIdx]) for yIdx in np.unique(flatPList[:,5])]
#
#totNumPlots=len(flatYlist)
#
#colors=plt.cm.viridis(np.linspace(0,1,totNumPlots))
#
#for y,color in zip(flatYlist,colors):
#    c=list(color)
#    c.remove(1.0)
#    c=tuple(c)
#    intPlot=mlab.points3d(y[:,0],y[:,1],y[:,2],mode='point',color=c)
#    intPlot.actor.property.render_points_as_spheres = True
#    intPlot.actor.property.point_size = 4
##
#mlab.show(stop=True)

# %%

"""plot grid points based on number of weights"""

#fig4 = mlab.figure(bgcolor=(0.5, 0.5, 0.5))
#
##fig.scene.disable_render = True
#
##phi1ax=mlab.quiver3d(0,0,0,360,0,0,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 0.160, 1))
##phi1ax.glyph.glyph_source.glyph_source.tip_radius = 0.02
##phi1ax.glyph.glyph_source.glyph_source.tip_length = 0.1
##phi1ax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
##phiax=mlab.quiver3d(0,0,0,0,180,0,line_width=0.5,scale_factor=1,mode='arrow',color=(1, 0.039, 0.039))
##phiax.glyph.glyph_source.glyph_source.tip_radius = 0.04
##phiax.glyph.glyph_source.glyph_source.tip_length = 0.2
##phiax.glyph.glyph_source.glyph_source.shaft_radius = 0.01
##phi2ax=mlab.quiver3d(0,0,0,0,0,360,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 1, 0.054))
##phi2ax.glyph.glyph_source.glyph_source.tip_radius = 0.02
##phi2ax.glyph.glyph_source.glyph_source.tip_length = 0.1
##phi2ax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
#
#phi1ax=mlab.quiver3d(0,0,0,360,0,0,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 0.160, 1))
#phi1ax.glyph.glyph_source.glyph_source.tip_radius = 0.02
#phi1ax.glyph.glyph_source.glyph_source.tip_length = 0.1
#phi1ax.glyph.glyph_source.glyph_source.shaft_radius = 0.005
#phiax=mlab.quiver3d(0,0,0,0,90,0,line_width=0.5,scale_factor=1,mode='arrow',color=(1, 0.039, 0.039))
#phiax.glyph.glyph_source.glyph_source.tip_radius = 0.08
#phiax.glyph.glyph_source.glyph_source.tip_length = 0.4
#phiax.glyph.glyph_source.glyph_source.shaft_radius = 0.02
#phi2ax=mlab.quiver3d(0,0,0,0,0,90,line_width=0.5,scale_factor=1,mode='arrow',color=(0.039, 1, 0.054))
#phi2ax.glyph.glyph_source.glyph_source.tip_radius = 0.08
#phi2ax.glyph.glyph_source.glyph_source.tip_length = 0.4
#phi2ax.glyph.glyph_source.glyph_source.shaft_radius = 0.02
#
#"""index of unique corresponds to grid point
#   value of unique corresponds to points correlated to that grid point"""
#   
#temp2 = np.asarray([len(u) for u in uniqueNN])
#
#pltSize = []
#
#for size in temp2:
#    if size > 5:
#        pltSize.append(5)
#    else:
#        pltSize.append(size)
#        
#pltSize = np.vstack(pltSize)
#
##pltSize = np.reshape(pltSize,(len(pltSize),1))
#
#eulerBySizeList = [np.vstack([eulerList[idx] for idx in range(len(eulerList)) if pltSize[idx]==size]) for size in np.unique(pltSize)]
#
#fundEulerBySizeList = [np.vstack([bunge for bunge in size if bunge[0] <= 360.0 and bunge[1] <= 90.0 and bunge[2] <= 90.0]) for size in eulerBySizeList]
#
#sizeOfEach = np.vstack([np.array((len(i),idx)) for idx,i in enumerate(eulerBySizeList)])
#
#colormap = plt.cm.viridis
#
#totNumPlots=len(fundEulerBySizeList)
#colors=colormap(np.linspace(0,1,totNumPlots))
#
#if len(eulerBySizeList) == 1:
#    sizeOfEach = sizeOfEach.reshape((1,2))    
#    for plotGroup,size in zip(sizeOfEach[:,1],np.unique(pltSize)):
#                 
#        bungeGrid=mlab.points3d(fundEulerBySizeList[plotGroup][:,0],
#                                fundEulerBySizeList[plotGroup][:,1],
#                                fundEulerBySizeList[plotGroup][:,2],
#                                mode='point',
#                                color=(1, 0.039, 0.039))
#        
#        bungeGrid.actor.property.render_points_as_spheres = True
#        bungeGrid.actor.property.point_size = float(size)    
#
#else:
#    sizeOfEach = sizeOfEach[np.argsort(sizeOfEach[:,0])]
#    
#    for plotGroup in sizeOfEach[:,1]:
#        
#        c=list(colors[plotGroup])
#        c.remove(1.0)
#        c=tuple(c)
#        
#        bungeGrid=mlab.points3d(fundEulerBySizeList[plotGroup][:,0],
#                                fundEulerBySizeList[plotGroup][:,1],
#                                fundEulerBySizeList[plotGroup][:,2],
#                                mode='point',
#                                color=c)
#        
#        bungeGrid.actor.property.render_points_as_spheres = True
#        bungeGrid.actor.property.point_size = float(plotGroup)
#        
##fig.scene.disable_render = False
#        
#mlab.show(stop=True)